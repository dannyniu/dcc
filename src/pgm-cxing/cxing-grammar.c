/* Auto-generated by "utils/grammar2rules.py". May be adapted. */
#define dcc_lalr_defining_grammar
#include "cxing-grammar.h"
#include "../langlex/langlex-cxing.h"
strvec_t *ns_rules_cxing;
void *goal_translation_unit(lalr_rule_params)
{
    int32_t production = hRule("cxing");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "TU", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *TU_base(lalr_rule_params)
{
    int32_t production = hRule("TU");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "entity-declaration", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *TU_genrule(lalr_rule_params)
{
    int32_t production = hRule("TU");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "TU", },
        { symtype_prod, .value = "entity-declaration", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ident_ident(lalr_rule_params)
{
    int32_t production = hRule("identifier");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_vtoken, .vtype = langlex_identifier, },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *strlit_strlit(lalr_rule_params)
{
    int32_t production = hRule("string-literal");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_vtoken, .vtype = langlex_strlit, },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *strlit_rawlit(lalr_rule_params)
{
    int32_t production = hRule("string-literal");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_vtoken, .vtype = langlex_rawlit, },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *strlit_strlitcat(lalr_rule_params)
{
    int32_t production = hRule("string-literal");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "string-literal", },
        { symtype_vtoken, .vtype = langlex_strlit, },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *strlit_rawlitcat(lalr_rule_params)
{
    int32_t production = hRule("string-literal");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "string-literal", },
        { symtype_vtoken, .vtype = langlex_rawlit, },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *const_true(lalr_rule_params)
{
    int32_t production = hRule("constant");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "true", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *const_false(lalr_rule_params)
{
    int32_t production = hRule("constant");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "false", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *const_null(lalr_rule_params)
{
    int32_t production = hRule("constant");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "null", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *const_declit(lalr_rule_params)
{
    int32_t production = hRule("constant");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_vtoken, .vtype = langlex_declit, },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *const_octlit(lalr_rule_params)
{
    int32_t production = hRule("constant");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_vtoken, .vtype = langlex_octlit, },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *const_hexlit(lalr_rule_params)
{
    int32_t production = hRule("constant");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_vtoken, .vtype = langlex_hexlit, },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *const_r64lit(lalr_rule_params)
{
    int32_t production = hRule("constant");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_vtoken, .vtype = langlex_r64lit, },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *const_decfplit(lalr_rule_params)
{
    int32_t production = hRule("constant");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_vtoken, .vtype = langlex_decfplit, },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *const_hexfplit(lalr_rule_params)
{
    int32_t production = hRule("constant");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_vtoken, .vtype = langlex_hexfplit, },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *const_charlit(lalr_rule_params)
{
    int32_t production = hRule("constant");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_vtoken, .vtype = langlex_charlit, },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *const_strlit(lalr_rule_params)
{
    int32_t production = hRule("constant");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "string-literal", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *primary_paren(lalr_rule_params)
{
    int32_t production = hRule("primary-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ")", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *primary_ident(lalr_rule_params)
{
    int32_t production = hRule("primary-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "identifier", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *primary_const(lalr_rule_params)
{
    int32_t production = hRule("primary-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "constant", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *postfix_degenerate(lalr_rule_params)
{
    int32_t production = hRule("postfix-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "primary-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *postfix_nullcoalesce(lalr_rule_params)
{
    int32_t production = hRule("postfix-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "postfix-expr", },
        { symtype_stoken, .value = "=?", },
        { symtype_prod, .value = "primary-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *postfix_indirect(lalr_rule_params)
{
    int32_t production = hRule("postfix-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "postfix-expr", },
        { symtype_stoken, .value = "[", },
        { symtype_prod, .value = "assign-expr", },
        { symtype_stoken, .value = "]", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *postfix_member(lalr_rule_params)
{
    int32_t production = hRule("postfix-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "postfix-expr", },
        { symtype_stoken, .value = ".", },
        { symtype_prod, .value = "identifier", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *postfix_inc(lalr_rule_params)
{
    int32_t production = hRule("postfix-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "postfix-expr", },
        { symtype_stoken, .value = "++", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *postfix_dec(lalr_rule_params)
{
    int32_t production = hRule("postfix-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "postfix-expr", },
        { symtype_stoken, .value = "--", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *postfix_funccall(lalr_rule_params)
{
    int32_t production = hRule("postfix-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "function-call", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *postfix_objdef(lalr_rule_params)
{
    int32_t production = hRule("postfix-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "object-notation", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *funccall_noarg(lalr_rule_params)
{
    int32_t production = hRule("function-call");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "postfix-expr", },
        { symtype_stoken, .value = "(", },
        { symtype_stoken, .value = ")", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *funccall_somearg(lalr_rule_params)
{
    int32_t production = hRule("function-call");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "funccall-start-nocomma", },
        { symtype_stoken, .value = ")", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *funcinvokenocomma_base(lalr_rule_params)
{
    int32_t production = hRule("funccall-start-nocomma");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "postfix-expr", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *funcinvokenocomma_genrule(lalr_rule_params)
{
    int32_t production = hRule("funccall-start-nocomma");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "funccall-start-nocomma", },
        { symtype_stoken, .value = ",", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *unary_degenerate(lalr_rule_params)
{
    int32_t production = hRule("unary-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "postfix-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *unary_inc(lalr_rule_params)
{
    int32_t production = hRule("unary-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "++", },
        { symtype_prod, .value = "unary-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *unary_dec(lalr_rule_params)
{
    int32_t production = hRule("unary-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "--", },
        { symtype_prod, .value = "unary-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *unary_positive(lalr_rule_params)
{
    int32_t production = hRule("unary-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "+", },
        { symtype_prod, .value = "unary-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *unary_negative(lalr_rule_params)
{
    int32_t production = hRule("unary-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "-", },
        { symtype_prod, .value = "unary-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *unary_bitcompl(lalr_rule_params)
{
    int32_t production = hRule("unary-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "~", },
        { symtype_prod, .value = "unary-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *unary_logicnot(lalr_rule_params)
{
    int32_t production = hRule("unary-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "!", },
        { symtype_prod, .value = "unary-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *mulexpr_degenerate(lalr_rule_params)
{
    int32_t production = hRule("mul-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *mulexpr_multiply(lalr_rule_params)
{
    int32_t production = hRule("mul-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "mul-expr", },
        { symtype_stoken, .value = "*", },
        { symtype_prod, .value = "unary-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *mulexpr_divide(lalr_rule_params)
{
    int32_t production = hRule("mul-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "mul-expr", },
        { symtype_stoken, .value = "/", },
        { symtype_prod, .value = "unary-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *mulexpr_remainder(lalr_rule_params)
{
    int32_t production = hRule("mul-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "mul-expr", },
        { symtype_stoken, .value = "%", },
        { symtype_prod, .value = "unary-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *addexpr_degenerate(lalr_rule_params)
{
    int32_t production = hRule("add-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "mul-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *addexpr_add(lalr_rule_params)
{
    int32_t production = hRule("add-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "add-expr", },
        { symtype_stoken, .value = "+", },
        { symtype_prod, .value = "mul-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *addexpr_subtract(lalr_rule_params)
{
    int32_t production = hRule("add-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "add-expr", },
        { symtype_stoken, .value = "-", },
        { symtype_prod, .value = "mul-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *shiftexpr_degenerate(lalr_rule_params)
{
    int32_t production = hRule("bit-shift-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "add-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *shiftexpr_lshift(lalr_rule_params)
{
    int32_t production = hRule("bit-shift-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "bit-shift-expr", },
        { symtype_stoken, .value = "<<", },
        { symtype_prod, .value = "add-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *shiftexpr_arshift(lalr_rule_params)
{
    int32_t production = hRule("bit-shift-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "bit-shift-expr", },
        { symtype_stoken, .value = ">>", },
        { symtype_prod, .value = "add-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *shiftexpr_rshift(lalr_rule_params)
{
    int32_t production = hRule("bit-shift-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "bit-shift-expr", },
        { symtype_stoken, .value = ">>>", },
        { symtype_prod, .value = "add-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *relops_degenerate(lalr_rule_params)
{
    int32_t production = hRule("rel-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "bit-shift-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *relops_lt(lalr_rule_params)
{
    int32_t production = hRule("rel-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "rel-expr", },
        { symtype_stoken, .value = "<", },
        { symtype_prod, .value = "bit-shift-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *relops_gt(lalr_rule_params)
{
    int32_t production = hRule("rel-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "rel-expr", },
        { symtype_stoken, .value = ">", },
        { symtype_prod, .value = "bit-shift-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *relops_le(lalr_rule_params)
{
    int32_t production = hRule("rel-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "rel-expr", },
        { symtype_stoken, .value = "<=", },
        { symtype_prod, .value = "bit-shift-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *relops_ge(lalr_rule_params)
{
    int32_t production = hRule("rel-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "rel-expr", },
        { symtype_stoken, .value = ">=", },
        { symtype_prod, .value = "bit-shift-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *eqops_degenerate(lalr_rule_params)
{
    int32_t production = hRule("eq-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "rel-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *eqops_eq(lalr_rule_params)
{
    int32_t production = hRule("eq-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "eq-expr", },
        { symtype_stoken, .value = "==", },
        { symtype_prod, .value = "rel-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *eqops_ne(lalr_rule_params)
{
    int32_t production = hRule("eq-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "eq-expr", },
        { symtype_stoken, .value = "!=", },
        { symtype_prod, .value = "rel-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *eqops_ideq(lalr_rule_params)
{
    int32_t production = hRule("eq-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "eq-expr", },
        { symtype_stoken, .value = "===", },
        { symtype_prod, .value = "rel-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *eqops_idne(lalr_rule_params)
{
    int32_t production = hRule("eq-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "eq-expr", },
        { symtype_stoken, .value = "!==", },
        { symtype_prod, .value = "rel-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *bitand_degenerate(lalr_rule_params)
{
    int32_t production = hRule("bit-and");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "eq-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *bitand_bitand(lalr_rule_params)
{
    int32_t production = hRule("bit-and");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "bit-and", },
        { symtype_stoken, .value = "&", },
        { symtype_prod, .value = "eq-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *bitxor_degenerate(lalr_rule_params)
{
    int32_t production = hRule("bit-xor");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "bit-and", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *bitxor_bitxor(lalr_rule_params)
{
    int32_t production = hRule("bit-xor");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "bit-xor", },
        { symtype_stoken, .value = "^", },
        { symtype_prod, .value = "bit-and", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *bitor_degenerate(lalr_rule_params)
{
    int32_t production = hRule("bit-or");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "bit-xor", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *bitor_bitor(lalr_rule_params)
{
    int32_t production = hRule("bit-or");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "bit-or", },
        { symtype_stoken, .value = "|", },
        { symtype_prod, .value = "bit-xor", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *logicand_degenerate(lalr_rule_params)
{
    int32_t production = hRule("logic-and");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "bit-or", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *logicand_logicand(lalr_rule_params)
{
    int32_t production = hRule("logic-and");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "logic-and", },
        { symtype_stoken, .value = "&&", },
        { symtype_prod, .value = "bit-or", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *logicor_degenerate(lalr_rule_params)
{
    int32_t production = hRule("logic-or");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "logic-and", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *logicor_logicor(lalr_rule_params)
{
    int32_t production = hRule("logic-or");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "logic-or", },
        { symtype_stoken, .value = "||", },
        { symtype_prod, .value = "logic-and", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *logicor_nullcoalesce(lalr_rule_params)
{
    int32_t production = hRule("logic-or");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "logic-or", },
        { symtype_stoken, .value = "??", },
        { symtype_prod, .value = "logic-and", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *tenary_degenerate(lalr_rule_params)
{
    int32_t production = hRule("cond-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "logic-or", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *tenary_tenary(lalr_rule_params)
{
    int32_t production = hRule("cond-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "logic-or", },
        { symtype_stoken, .value = "?", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ":", },
        { symtype_prod, .value = "cond-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_degenerate(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "cond-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_directassign(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        { symtype_stoken, .value = "=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_mulassign(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        { symtype_stoken, .value = "*=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_divassign(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        { symtype_stoken, .value = "/=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_remassign(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        { symtype_stoken, .value = "%=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_addassign(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        { symtype_stoken, .value = "+=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_subassign(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        { symtype_stoken, .value = "-=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_lshiftassign(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        { symtype_stoken, .value = "<<=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_arshiftassign(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        { symtype_stoken, .value = ">>=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_rshiftassign(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        { symtype_stoken, .value = ">>>=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_andassign(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        { symtype_stoken, .value = "&=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_xorassign(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        { symtype_stoken, .value = "^=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *assignment_orassign(lalr_rule_params)
{
    int32_t production = hRule("assign-expr");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "unary-expr", },
        { symtype_stoken, .value = "|=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *exprlist_degenerate(lalr_rule_params)
{
    int32_t production = hRule("expressions-list");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *exprlist_exprlist(lalr_rule_params)
{
    int32_t production = hRule("expressions-list");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ",", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *and_phrase_ion_and(lalr_rule_params)
{
    int32_t production = hRule("conj-ion");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "conj-atom", },
        { symtype_stoken, .value = "and", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *and_phrase_ion_then(lalr_rule_params)
{
    int32_t production = hRule("conj-ion");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "conj-atom", },
        { symtype_stoken, .value = "_Then", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *and_phrase_atom_degenerate(lalr_rule_params)
{
    int32_t production = hRule("conj-atom");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "expressions-list", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *and_phrase_atom_atomize(lalr_rule_params)
{
    int32_t production = hRule("conj-atom");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "conj-ion", },
        { symtype_prod, .value = "expressions-list", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *or_phrase_ion_or(lalr_rule_params)
{
    int32_t production = hRule("disj-ion");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "disj-atom", },
        { symtype_stoken, .value = "or", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *or_phrase_ion_nc(lalr_rule_params)
{
    int32_t production = hRule("disj-ion");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "disj-atom", },
        { symtype_stoken, .value = "_Fallback", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *or_phrase_ion_ctrl_flow(lalr_rule_params)
{
    int32_t production = hRule("disj-ion");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "conj-ion", },
        { symtype_prod, .value = "control-flow-ions", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *or_phrase_atom_degenerate(lalr_rule_params)
{
    int32_t production = hRule("disj-atom");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "conj-atom", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *or_phrase_atom_atomize(lalr_rule_params)
{
    int32_t production = hRule("disj-atom");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "disj-ion", },
        { symtype_prod, .value = "conj-atom", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *phrase_stmt_base(lalr_rule_params)
{
    int32_t production = hRule("phrase-stmt");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "disj-atom", },
        { symtype_stoken, .value = ";", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *phrase_stmt_ctrl_flow(lalr_rule_params)
{
    int32_t production = hRule("phrase-stmt");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "control-flow-molecule", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *phrase_stmt_conj_ctrl_flow(lalr_rule_params)
{
    int32_t production = hRule("phrase-stmt");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "conj-ion", },
        { symtype_prod, .value = "control-flow-molecule", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *phrase_stmt_disj_ctrl_flow(lalr_rule_params)
{
    int32_t production = hRule("phrase-stmt");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "disj-ion", },
        { symtype_prod, .value = "control-flow-molecule", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ctrl_flow_ion_op_or(lalr_rule_params)
{
    int32_t production = hRule("control-flow-ions");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "control-flow-operator", },
        { symtype_stoken, .value = "or", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ctrl_flow_ion_op_nc(lalr_rule_params)
{
    int32_t production = hRule("control-flow-ions");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "control-flow-operator", },
        { symtype_stoken, .value = "_Fallback", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ctrl_flow_ion_labelledop_or(lalr_rule_params)
{
    int32_t production = hRule("control-flow-ions");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "control-flow-operator", },
        { symtype_prod, .value = "identifier", },
        { symtype_stoken, .value = "or", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ctrl_flow_ion_labelledop_nc(lalr_rule_params)
{
    int32_t production = hRule("control-flow-ions");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "control-flow-operator", },
        { symtype_prod, .value = "identifier", },
        { symtype_stoken, .value = "_Fallback", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ctrl_flow_ion_returnnull_or(lalr_rule_params)
{
    int32_t production = hRule("control-flow-ions");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "return", },
        { symtype_stoken, .value = "or", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ctrl_flow_ion_returnnull_nc(lalr_rule_params)
{
    int32_t production = hRule("control-flow-ions");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "return", },
        { symtype_stoken, .value = "_Fallback", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ctrl_flow_ion_returnexpr_or(lalr_rule_params)
{
    int32_t production = hRule("control-flow-ions");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "return", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = "or", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ctrl_flow_ion_returnexpr_nc(lalr_rule_params)
{
    int32_t production = hRule("control-flow-ions");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "return", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = "_Fallback", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ctrl_flow_molecule_op(lalr_rule_params)
{
    int32_t production = hRule("control-flow-molecule");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "control-flow-operator", },
        { symtype_stoken, .value = ";", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ctrl_flow_molecule_labelledop(lalr_rule_params)
{
    int32_t production = hRule("control-flow-molecule");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "control-flow-operator", },
        { symtype_prod, .value = "identifier", },
        { symtype_stoken, .value = ";", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ctrl_flow_molecule_returnnull(lalr_rule_params)
{
    int32_t production = hRule("control-flow-molecule");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "return", },
        { symtype_stoken, .value = ";", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *ctrl_flow_molecule_returnexpr(lalr_rule_params)
{
    int32_t production = hRule("control-flow-molecule");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "return", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ";", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *flowctrlop_break(lalr_rule_params)
{
    int32_t production = hRule("control-flow-operator");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "break", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *flowctrlop_continue(lalr_rule_params)
{
    int32_t production = hRule("control-flow-operator");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "continue", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *stmt_emptystmt(lalr_rule_params)
{
    int32_t production = hRule("statement");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = ";", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *stmt_labelled(lalr_rule_params)
{
    int32_t production = hRule("statement");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "identifier", },
        { symtype_stoken, .value = ":", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *stmt_phrase(lalr_rule_params)
{
    int32_t production = hRule("statement");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "phrase-stmt", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *stmt_cond(lalr_rule_params)
{
    int32_t production = hRule("statement");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "conditionals", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *stmt_while(lalr_rule_params)
{
    int32_t production = hRule("statement");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "while-loop", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *stmt_dowhile(lalr_rule_params)
{
    int32_t production = hRule("statement");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "do-while-loop", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *stmt_for(lalr_rule_params)
{
    int32_t production = hRule("statement");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "for-loop", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *stmt_brace(lalr_rule_params)
{
    int32_t production = hRule("statement");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "{", },
        { symtype_prod, .value = "statements-list", },
        { symtype_stoken, .value = "}", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *stmt_decl(lalr_rule_params)
{
    int32_t production = hRule("statement");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "declaration", },
        { symtype_stoken, .value = ";", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *condstmt_base(lalr_rule_params)
{
    int32_t production = hRule("conditionals");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "predicated-clause", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *condstmt_else(lalr_rule_params)
{
    int32_t production = hRule("conditionals");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "predicated-clause", },
        { symtype_stoken, .value = "else", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *predclause_base(lalr_rule_params)
{
    int32_t production = hRule("predicated-clause");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "if", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *predclause_genrule(lalr_rule_params)
{
    int32_t production = hRule("predicated-clause");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "predicated-clause", },
        { symtype_stoken, .value = "elif", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *while_rule(lalr_rule_params)
{
    int32_t production = hRule("while-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "while", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *dowhile_rule(lalr_rule_params)
{
    int32_t production = hRule("do-while-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "do", },
        { symtype_stoken, .value = "{", },
        { symtype_prod, .value = "statements-list", },
        { symtype_stoken, .value = "}", },
        { symtype_stoken, .value = "while", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ")", },
        { symtype_stoken, .value = ";", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *for_forever(lalr_rule_params)
{
    int32_t production = hRule("for-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "for", },
        { symtype_stoken, .value = "(", },
        { symtype_stoken, .value = ";", },
        { symtype_stoken, .value = ";", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *for_iterated(lalr_rule_params)
{
    int32_t production = hRule("for-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "for", },
        { symtype_stoken, .value = "(", },
        { symtype_stoken, .value = ";", },
        { symtype_stoken, .value = ";", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *for_conditioned(lalr_rule_params)
{
    int32_t production = hRule("for-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "for", },
        { symtype_stoken, .value = "(", },
        { symtype_stoken, .value = ";", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ";", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *for_controlled(lalr_rule_params)
{
    int32_t production = hRule("for-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "for", },
        { symtype_stoken, .value = "(", },
        { symtype_stoken, .value = ";", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ";", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *for_initonly(lalr_rule_params)
{
    int32_t production = hRule("for-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "for", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ";", },
        { symtype_stoken, .value = ";", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *for_nocond(lalr_rule_params)
{
    int32_t production = hRule("for-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "for", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ";", },
        { symtype_stoken, .value = ";", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *for_noiter(lalr_rule_params)
{
    int32_t production = hRule("for-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "for", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ";", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ";", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *for_classic(lalr_rule_params)
{
    int32_t production = hRule("for-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "for", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ";", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ";", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *for_vardecl(lalr_rule_params)
{
    int32_t production = hRule("for-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "for", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "declaration", },
        { symtype_stoken, .value = ";", },
        { symtype_stoken, .value = ";", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *for_vardecl_nocond(lalr_rule_params)
{
    int32_t production = hRule("for-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "for", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "declaration", },
        { symtype_stoken, .value = ";", },
        { symtype_stoken, .value = ";", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *for_vardecl_noiter(lalr_rule_params)
{
    int32_t production = hRule("for-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "for", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "declaration", },
        { symtype_stoken, .value = ";", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ";", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *for_vardecl_controlled(lalr_rule_params)
{
    int32_t production = hRule("for-loop");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "for", },
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "declaration", },
        { symtype_stoken, .value = ";", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ";", },
        { symtype_prod, .value = "expressions-list", },
        { symtype_stoken, .value = ")", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *stmtlist_base(lalr_rule_params)
{
    int32_t production = hRule("statements-list");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *stmtlist_genrule(lalr_rule_params)
{
    int32_t production = hRule("statements-list");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "statements-list", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *decl_singledecl(lalr_rule_params)
{
    int32_t production = hRule("declaration");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "decl", },
        { symtype_prod, .value = "identifier", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *decl_singledeclinit(lalr_rule_params)
{
    int32_t production = hRule("declaration");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "decl", },
        { symtype_prod, .value = "identifier", },
        { symtype_stoken, .value = "=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *decl_declarelist1(lalr_rule_params)
{
    int32_t production = hRule("declaration");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "declaration", },
        { symtype_stoken, .value = ",", },
        { symtype_prod, .value = "identifier", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *decl_declarelist2(lalr_rule_params)
{
    int32_t production = hRule("declaration");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "declaration", },
        { symtype_stoken, .value = ",", },
        { symtype_prod, .value = "identifier", },
        { symtype_stoken, .value = "=", },
        { symtype_prod, .value = "assign-expr", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *funcdecl_subr(lalr_rule_params)
{
    int32_t production = hRule("function-declaration");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "subr", },
        { symtype_prod, .value = "identifier", },
        { symtype_prod, .value = "arguments-list", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *funcdecl_method(lalr_rule_params)
{
    int32_t production = hRule("function-declaration");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "method", },
        { symtype_prod, .value = "identifier", },
        { symtype_prod, .value = "arguments-list", },
        { symtype_prod, .value = "statement", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *arglist_empty(lalr_rule_params)
{
    int32_t production = hRule("arguments-list");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "(", },
        { symtype_stoken, .value = ")", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *arglist_some(lalr_rule_params)
{
    int32_t production = hRule("arguments-list");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "arguments-begin", },
        { symtype_stoken, .value = ")", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *args_base(lalr_rule_params)
{
    int32_t production = hRule("arguments-begin");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "(", },
        { symtype_prod, .value = "identifier", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *args_genrule(lalr_rule_params)
{
    int32_t production = hRule("arguments-begin");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "arguments-begin", },
        { symtype_stoken, .value = ",", },
        { symtype_prod, .value = "identifier", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *entdecl_srcinc(lalr_rule_params)
{
    int32_t production = hRule("entity-declaration");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "_Include", },
        { symtype_vtoken, .vtype = langlex_strlit, },
        { symtype_stoken, .value = ";", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *entdecl_extern(lalr_rule_params)
{
    int32_t production = hRule("entity-declaration");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_stoken, .value = "extern", },
        { symtype_prod, .value = "function-declaration", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

void *entdecl_implicit(lalr_rule_params)
{
    int32_t production = hRule("entity-declaration");
    static lalr_rule_symbol_t symbolseq[] = {
        { symtype_prod, .value = "function-declaration", },
        {0},
    };
    (void)ctx;
    return lalr_rule_actions_generic(lalr_rule_gen_args);
}

lalr_rule_t cxing_grammar_rules[] = {
    goal_translation_unit,
    TU_base,
    TU_genrule,
    ident_ident,
    strlit_strlit,
    strlit_rawlit,
    strlit_strlitcat,
    strlit_rawlitcat,
    const_true,
    const_false,
    const_null,
    const_declit,
    const_octlit,
    const_hexlit,
    const_r64lit,
    const_decfplit,
    const_hexfplit,
    const_charlit,
    const_strlit,
    primary_paren,
    primary_ident,
    primary_const,
    postfix_degenerate,
    postfix_nullcoalesce,
    postfix_indirect,
    postfix_member,
    postfix_inc,
    postfix_dec,
    postfix_funccall,
    postfix_objdef,
    funccall_noarg,
    funccall_somearg,
    funcinvokenocomma_base,
    funcinvokenocomma_genrule,
    unary_degenerate,
    unary_inc,
    unary_dec,
    unary_positive,
    unary_negative,
    unary_bitcompl,
    unary_logicnot,
    mulexpr_degenerate,
    mulexpr_multiply,
    mulexpr_divide,
    mulexpr_remainder,
    addexpr_degenerate,
    addexpr_add,
    addexpr_subtract,
    shiftexpr_degenerate,
    shiftexpr_lshift,
    shiftexpr_arshift,
    shiftexpr_rshift,
    relops_degenerate,
    relops_lt,
    relops_gt,
    relops_le,
    relops_ge,
    eqops_degenerate,
    eqops_eq,
    eqops_ne,
    eqops_ideq,
    eqops_idne,
    bitand_degenerate,
    bitand_bitand,
    bitxor_degenerate,
    bitxor_bitxor,
    bitor_degenerate,
    bitor_bitor,
    logicand_degenerate,
    logicand_logicand,
    logicor_degenerate,
    logicor_logicor,
    logicor_nullcoalesce,
    tenary_degenerate,
    tenary_tenary,
    assignment_degenerate,
    assignment_directassign,
    assignment_mulassign,
    assignment_divassign,
    assignment_remassign,
    assignment_addassign,
    assignment_subassign,
    assignment_lshiftassign,
    assignment_arshiftassign,
    assignment_rshiftassign,
    assignment_andassign,
    assignment_xorassign,
    assignment_orassign,
    exprlist_degenerate,
    exprlist_exprlist,
    and_phrase_ion_and,
    and_phrase_ion_then,
    and_phrase_atom_degenerate,
    and_phrase_atom_atomize,
    or_phrase_ion_or,
    or_phrase_ion_nc,
    or_phrase_ion_ctrl_flow,
    or_phrase_atom_degenerate,
    or_phrase_atom_atomize,
    phrase_stmt_base,
    phrase_stmt_ctrl_flow,
    phrase_stmt_conj_ctrl_flow,
    phrase_stmt_disj_ctrl_flow,
    ctrl_flow_ion_op_or,
    ctrl_flow_ion_op_nc,
    ctrl_flow_ion_labelledop_or,
    ctrl_flow_ion_labelledop_nc,
    ctrl_flow_ion_returnnull_or,
    ctrl_flow_ion_returnnull_nc,
    ctrl_flow_ion_returnexpr_or,
    ctrl_flow_ion_returnexpr_nc,
    ctrl_flow_molecule_op,
    ctrl_flow_molecule_labelledop,
    ctrl_flow_molecule_returnnull,
    ctrl_flow_molecule_returnexpr,
    flowctrlop_break,
    flowctrlop_continue,
    stmt_emptystmt,
    stmt_labelled,
    stmt_phrase,
    stmt_cond,
    stmt_while,
    stmt_dowhile,
    stmt_for,
    stmt_brace,
    stmt_decl,
    condstmt_base,
    condstmt_else,
    predclause_base,
    predclause_genrule,
    while_rule,
    dowhile_rule,
    for_forever,
    for_iterated,
    for_conditioned,
    for_controlled,
    for_initonly,
    for_nocond,
    for_noiter,
    for_classic,
    for_vardecl,
    for_vardecl_nocond,
    for_vardecl_noiter,
    for_vardecl_controlled,
    stmtlist_base,
    stmtlist_genrule,
    decl_singledecl,
    decl_singledeclinit,
    decl_declarelist1,
    decl_declarelist2,
    funcdecl_subr,
    funcdecl_method,
    arglist_empty,
    arglist_some,
    args_base,
    args_genrule,
    entdecl_srcinc,
    entdecl_extern,
    entdecl_implicit,
    NULL,
};
