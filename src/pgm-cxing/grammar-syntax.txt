cxing % goal : TU % translation_unit ;

TU % TU
: entity-declaration % base
| TU entity-declaration % genrule
;

identifier % ident
: langlex_identifier % ident
;

string-literal % strlit
: langlex_strlit % strlit
| langlex_rawlit % rawlit
| string-literal langlex_strlit % strlitcat
| string-literal langlex_rawlit % rawlitcat
;

constant % const
: "true" % true
| "false" % false
| "null" % null
| langlex_declit % declit
| langlex_octlit % octlit
| langlex_hexlit % hexlit
| langlex_r64lit % r64lit
| langlex_decfplit % decfplit
| langlex_hexfplit % hexfplit
| langlex_charlit % charlit
| string-literal % strlit
;

primary-expr % primary
: "(" expressions-list ")" % paren
| identifier % ident
| constant % const
;

postfix-expr % postfix
: primary-expr % degenerate
| postfix-expr "=?" primary-expr % nullcoalesce
| postfix-expr "[" assign-expr "]" % indirect
| postfix-expr "." identifier % member
| postfix-expr "++" % inc
| postfix-expr "--" % dec
| function-call % funccall
| object-notation % objdef
;

function-call % funccall
: postfix-expr "(" ")" % noarg
| funccall-start-nocomma ")" % somearg
;

funccall-start-nocomma % funcinvokenocomma
: postfix-expr "(" assign-expr % base
| funccall-start-nocomma "," assign-expr % genrule
;

unary-expr % unary
: postfix-expr % degenerate
| "++" unary-expr % inc
| "--" unary-expr % dec
| "+" unary-expr % positive
| "-" unary-expr % negative
| "~" unary-expr % bitcompl
| "!" unary-expr % logicnot
;

mul-expr % mulexpr
: unary-expr % degenerate
| mul-expr "*" unary-expr % multiply
| mul-expr "/" unary-expr % divide
| mul-expr "%" unary-expr % remainder
;

add-expr % addexpr
: mul-expr % degenerate
| add-expr "+" mul-expr % add
| add-expr "-" mul-expr % subtract
;

bit-shift-expr % shiftexpr
: add-expr % degenerate
| bit-shift-expr "<<" add-expr % lshift
| bit-shift-expr ">>" add-expr % arshift
| bit-shift-expr ">>>" add-expr % rshift
;

rel-expr % relops
: bit-shift-expr % degenerate
| rel-expr "<" bit-shift-expr % lt
| rel-expr ">" bit-shift-expr % gt
| rel-expr "<=" bit-shift-expr % le
| rel-expr ">=" bit-shift-expr % ge
;

eq-expr % eqops
: rel-expr % degenerate
| eq-expr "==" rel-expr % eq
| eq-expr "!=" rel-expr % ne
| eq-expr "===" rel-expr % ideq
| eq-expr "!==" rel-expr % idne
;

bit-and % bitand
: eq-expr % degenerate
| bit-and "&" eq-expr % bitand
;

bit-xor % bitxor
: bit-and % degenerate
| bit-xor "^" bit-and % bitxor
;

bit-or % bitor
: bit-xor % degenerate
| bit-or "|" bit-xor % bitor
;

logic-and % logicand
: bit-or % degenerate
| logic-and "&&" bit-or % logicand
;

logic-or % logicor
: logic-and % degenerate
| logic-or "||" logic-and % logicor
| logic-or "??" logic-and % nullcoalesce
;

cond-expr % tenary
: logic-or % degenerate
| logic-or "?" expressions-list ":" cond-expr % tenary
;

assign-expr % assignment
: cond-expr % degenerate
| unary-expr "=" assign-expr % directassign
| unary-expr "*=" assign-expr % mulassign
| unary-expr "/=" assign-expr % divassign
| unary-expr "%=" assign-expr % remassign
| unary-expr "+=" assign-expr % addassign
| unary-expr "-=" assign-expr % subassign
| unary-expr "<<=" assign-expr % lshiftassign
| unary-expr ">>=" assign-expr % arshiftassign
| unary-expr ">>>=" assign-expr % rshiftassign
| unary-expr "&=" assign-expr % andassign
| unary-expr "^=" assign-expr % xorassign
| unary-expr "|=" assign-expr % orassign
;

expressions-list % exprlist
: assign-expr % degenerate
| expressions-list "," assign-expr % exprlist
;

conj-ion % and_phrase_ion
: conj-atom "and" % and
| conj-atom "_Then" % then
;

conj-atom % and_phrase_atom
: expressions-list % degenerate
| conj-ion expressions-list % atomize
;

disj-ion % or_phrase_ion
: disj-atom "or" % or
| disj-atom "_Fallback" % nc
| conj-ion control-flow-ions % ctrl_flow
;

disj-atom % or_phrase_atom
: conj-atom % degenerate
| disj-ion conj-atom % atomize
;

phrase-stmt % phrase_stmt
: disj-atom ";" % base
| control-flow-molecule % ctrl_flow
| conj-ion control-flow-molecule % conj_ctrl_flow
| disj-ion control-flow-molecule % disj_ctrl_flow
;

control-flow-ions % ctrl_flow_ion
: control-flow-operator "or" % op_or
| control-flow-operator "_Fallback" % op_nc
| control-flow-operator identifier "or" % labelledop_or
| control-flow-operator identifier "_Fallback" % labelledop_nc
| "return" "or" % returnnull_or
| "return" "_Fallback" % returnnull_nc
| "return" expressions-list "or" % returnexpr_or
| "return" expressions-list "_Fallback" % returnexpr_nc
;

control-flow-molecule % ctrl_flow_molecule
: control-flow-operator ";" % op
| control-flow-operator identifier ";" % labelledop
| "return" ";" % returnnull
| "return" expressions-list ";" % returnexpr
;

control-flow-operator % flowctrlop
: "break" % break
| "continue" % continue
;

statement % stmt
: ";" % emptystmt
| identifier ":" statement % labelled
| phrase-stmt % phrase
| conditionals % cond
| while-loop % while
| do-while-loop % dowhile
| for-loop % for
| "{" statements-list "}" % brace
| declaration ";" % decl
;

conditionals % condstmt
: predicated-clause % base
| predicated-clause "else" statement % else
;

predicated-clause % predclause
: "if" "(" expressions-list ")" statement % base
| predicated-clause "elif" "(" expressions-list ")" statement % genrule
;

while-loop % while
: "while" "(" expressions-list ")" statement % rule
;

do-while-loop % dowhile
: "do" "{" statements-list "}" "while" "(" expressions-list ")" ";" % rule
;

for-loop % for
: "for" "(" ";" ";" ")" statement % forever

| "for" "(" ";" ";" expressions-list ")" statement % iterated

| "for" "(" ";" expressions-list ";" ")" statement % conditioned

| "for" "(" ";" expressions-list ";"
                expressions-list ")" statement % controlled

| "for" "(" expressions-list ";" ";" ")" statement % initonly

| "for" "(" expressions-list ";" ";"
            expressions-list ")" statement % nocond

| "for" "(" expressions-list ";"
            expressions-list ";" ")" statement % noiter

| "for" "(" expressions-list ";"
            expressions-list ";"
            expressions-list ")" statement % classic

| "for" "(" declaration ";" ";" ")" statement % vardecl

| "for" "(" declaration ";" ";"
            expressions-list ")" statement % vardecl_nocond

| "for" "(" declaration ";"
            expressions-list ";" ")" statement % vardecl_noiter

| "for" "(" declaration ";"
            expressions-list ";"
            expressions-list ")" statement % vardecl_controlled
;

statements-list % stmtlist
: statement % base
| statements-list statement % genrule
;

declaration % decl
: "decl" identifier % singledecl
| "decl" identifier "=" assign-expr % singledeclinit
| declaration "," identifier % declarelist1
| declaration "," identifier "=" assign-expr % declarelist2
;

function-declaration % funcdecl
: "subr" identifier arguments-list statement % subr
| "method" identifier arguments-list statement % method
;

arguments-list % arglist
: "(" ")" % empty
| arguments-begin ")" % some
;

arguments-begin % args
: "(" identifier % base
| arguments-begin "," identifier % genrule
;

entity-declaration % entdecl
: "_Include" langlex_strlit ";" % srcinc
| "extern" function-declaration % extern
| function-declaration % implicit
;
